= OpenAPI Generator Spring Reproducer: nested discriminator + oneOf + allOf breaks model generation
:toc:

This repository reproduces a mis-generation in OpenAPI Generator (7.15.0) for the `spring` server stub when using a nested polymorphic property with a `discriminator` on a base schema (`oneOf`) and subtype inheritance via `allOf`.

== Environment

* Java: 21
* OpenAPI Generator Maven Plugin: 7.15.0
* Generator: `spring`
* Config options:
** `useOneOfInterfaces=true`
** `interfaceOnly=true`
** `useSpringBoot3=true`
** `openApiNullable=false`

== How to reproduce

[source,shell]
----
./mvnw clean generate-sources
----

This generates sources into `target/generated-sources/openapi`.

== The Minimal Spec

The minimal spec is in `openapi-discriminator-spec.yaml` and defines:

* Container `Drawing` with nested polymorphic field `shape`
* Base `Shape` with `discriminator: { propertyName: type, mapping: { circle, rectangle } }` and `oneOf`
* Subtypes `Circle` and `Rectangle` defined with `allOf: [ $ref: Shape, {...} ]`

This mirrors a common “inheritance + discriminator” setup.

== Actual generated code (broken)

The generator creates an *interface* for `Shape` and then makes subtypes `extend` it as if it were a *class*, and also leaks sibling fields into each subtype via bogus `super.*` calls.

=== Shape.java (interface)

[source,java]
----
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = Circle.class, name = "circle"),
  @JsonSubTypes.Type(value = Rectangle.class, name = "rectangle"),
  @JsonSubTypes.Type(value = Circle.class, name = "Circle"),
  @JsonSubTypes.Type(value = Rectangle.class, name = "Rectangle")
})
public interface Shape {
    public String getType();
}
----

Note the duplicate subtype names (`circle` and `Circle`).

=== Circle.java (extends interface + pulls in rectangle fields)

[source,java]
----
public class Circle extends Shape implements Shape {   // <-- cannot extend an interface
  public enum TypeEnum { CIRCLE("circle"); ... }
  private TypeEnum type;
  private Integer radius;

  public Circle(TypeEnum type, Integer radius, Integer width, Integer height) { // <-- width/height shouldn't be here
    super(type, radius, width, height);  // <-- bogus super(...) call; Shape is an interface
    this.type = type;
    this.radius = radius;
  }

  public Circle width(Integer width) {    // <-- rectangle field leaked into Circle
    super.width(width);                   // <-- bogus
    return this;
  }
  public Circle height(Integer height) {  // <-- leaked too
    super.height(height);
    return this;
  }
}
----

=== Rectangle.java (extends interface + pulls in circle field)

[source,java]
----
public class Rectangle extends Shape implements Shape {
  public enum TypeEnum { RECTANGLE("rectangle"); ... }
  private TypeEnum type;
  private Integer width;
  private Integer height;

  public Rectangle(TypeEnum type, Integer width, Integer height, Integer radius) { // <-- radius shouldn't be here
    super(type, radius, width, height);                                           // <-- bogus
    this.type = type;
    this.width = width;
    this.height = height;
  }

  public Rectangle radius(Integer radius) {  // <-- circle field leaked into Rectangle
    super.radius(radius);                    // <-- bogus
    return this;
  }
}
----

== Expected behavior

With `useOneOfInterfaces=true`, the generator should produce a **proper interface-based hierarchy**:

* `Shape` is a **pure interface** that defines only the discriminator method `getType()` (with Jackson polymorphism annotations).
* Subtypes **implement** `Shape` (not extend), declare **only their own fields**, and return their specific type value in `getType()`.
* No field leakage between subtypes - Circle should only have `radius`, Rectangle should only have `width` and `height`.
* No `super.*` method calls since Shape is an interface without implementations.
* No duplicate subtype names in the discriminator mapping.
* No bogus constructors with parameters from sibling types.

== Correct expected code with useOneOfInterfaces=true (one possible approach)

=== ShapeType.java (shared enum)

[source,java]
----
@JsonValue
public enum ShapeType {
    CIRCLE("circle"),
    RECTANGLE("rectangle");
    
    private final String value;
    
    ShapeType(String value) {
        this.value = value;
    }
    
    public String getValue() {
        return value;
    }
    
    @JsonCreator
    public static ShapeType fromValue(String value) {
        for (ShapeType type : ShapeType.values()) {
            if (type.value.equals(value)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
}
----

=== Shape.java (interface - correct)

[source,java]
----
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = Circle.class, name = "circle"),
  @JsonSubTypes.Type(value = Rectangle.class, name = "rectangle")
})
public interface Shape {
    ShapeType getType();
}
----

=== Circle.java (implements interface - correct)

[source,java]
----
public class Circle implements Shape {
  private ShapeType type = ShapeType.CIRCLE;
  private Integer radius;

  // Only Circle's own parameters
  public Circle(Integer radius) {
    this.radius = radius;
  }

  @Override
  public ShapeType getType() {
    return type;
  }

  // Only Circle's own methods - no width/height
  public Circle radius(Integer radius) {
    this.radius = radius;
    return this;
  }
  
  // getters/setters only for Circle fields...
}
----

=== Rectangle.java (implements interface - correct)

[source,java]
----
public class Rectangle implements Shape {
  private ShapeType type = ShapeType.RECTANGLE;
  private Integer width;
  private Integer height;

  // Only Rectangle's own parameters  
  public Rectangle(Integer width, Integer height) {
    this.width = width;
    this.height = height;
  }

  @Override
  public ShapeType getType() {
    return type;
  }

  // Only Rectangle's own methods - no radius
  public Rectangle width(Integer width) {
    this.width = width;
    return this;
  }
  
  public Rectangle height(Integer height) {
    this.height = height;
    return this;
  }
  
  // getters/setters only for Rectangle fields...
}
----